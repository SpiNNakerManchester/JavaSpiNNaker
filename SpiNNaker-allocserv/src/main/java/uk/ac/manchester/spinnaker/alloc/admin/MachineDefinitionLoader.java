/*
 * Copyright (c) 2021 The University of Manchester
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package uk.ac.manchester.spinnaker.alloc.admin;

import static java.util.Collections.unmodifiableList;
import static java.util.Collections.unmodifiableMap;
import static java.util.Collections.unmodifiableSet;
import static org.sqlite.SQLiteErrorCode.SQLITE_CONSTRAINT_CHECK;
import static uk.ac.manchester.spinnaker.alloc.DatabaseEngine.transaction;
import static uk.ac.manchester.spinnaker.alloc.DatabaseEngine.update;

import java.io.File;
import java.io.IOException;
import java.sql.Connection;
import java.sql.SQLException;
import java.util.EnumSet;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Optional;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import javax.validation.ConstraintViolation;
import javax.validation.Valid;
import javax.validation.ValidatorFactory;
import javax.validation.constraints.AssertTrue;
import javax.validation.constraints.Max;
import javax.validation.constraints.Min;
import javax.validation.constraints.NotBlank;
import javax.validation.constraints.NotNull;
import javax.validation.constraints.Positive;
import javax.validation.constraints.PositiveOrZero;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;
import org.sqlite.SQLiteException;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.core.JsonParseException;
import com.fasterxml.jackson.databind.JsonMappingException;
import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
import com.fasterxml.jackson.databind.annotation.JsonPOJOBuilder;
import com.fasterxml.jackson.databind.json.JsonMapper;

import uk.ac.manchester.spinnaker.alloc.DatabaseEngine;
import uk.ac.manchester.spinnaker.alloc.DatabaseEngine.Update;
import uk.ac.manchester.spinnaker.alloc.IPAddress;
import uk.ac.manchester.spinnaker.alloc.SQLQueries;
import uk.ac.manchester.spinnaker.alloc.allocator.DirInfo;
import uk.ac.manchester.spinnaker.alloc.allocator.Direction;
import uk.ac.manchester.spinnaker.machine.ChipLocation;

/**
 * Loads definitions of machines from JSON, as generated by {@code py2json}.
 *
 * @author Donal Fellows
 */
@Component
public class MachineDefinitionLoader extends SQLQueries {
	private static final int DECIMAL = 10;

	/**
	 * Triad coordinates.
	 *
	 * @author Donal Fellows
	 */
	public static final class TriadCoords implements Comparable<TriadCoords> {
		/** X coordinate. */
		@PositiveOrZero(message = "x coordinate must not be negative")
		public final int x;

		/** Y coordinate. */
		@PositiveOrZero(message = "y coordinate must not be negative")
		public final int y;

		/** Z coordinate. */
		@Min(value = 0, message = "z coordinate must not be negative")
		@Max(value = 2, message = "z coordinate must not be more than 2")
		public final int z;

		@JsonCreator
		public TriadCoords(@JsonProperty("x") int x, @JsonProperty("y") int y,
				@JsonProperty("z") int z) {
			this.x = x;
			this.y = y;
			this.z = z;
		}

		private static final Pattern PATTERN;

		static {
			PATTERN = Pattern.compile("^\\[x:(\\d+),y:(\\d+),z:(\\d+)\\]$");
		}

		@JsonCreator
		public TriadCoords(String serialForm) {
			Matcher m = PATTERN.matcher(serialForm);
			if (!m.matches()) {
				throw new IllegalArgumentException(
						"bad argument: " + serialForm);
			}
			int idx = 0;
			x = Integer.parseInt(m.group(++idx), DECIMAL);
			y = Integer.parseInt(m.group(++idx), DECIMAL);
			z = Integer.parseInt(m.group(++idx), DECIMAL);
		}

		private static final int TRIAD_SIZE = 12;

		private static final int TRIAD_MAJOR_OFFSET = 8;

		private static final int TRIAD_MINOR_OFFSET = 4;

		ChipLocation chipLocation() {
			int rootX = x * TRIAD_SIZE;
			int rootY = y * TRIAD_SIZE;
			switch (z) {
			case 0:
				break;
			case 1:
				rootX += TRIAD_MAJOR_OFFSET;
				rootY += TRIAD_MINOR_OFFSET;
				break;
			case 2:
				rootX += TRIAD_MINOR_OFFSET;
				rootY += TRIAD_MAJOR_OFFSET;
				break;
			default:
				throw new IllegalArgumentException("bad Z coordinate");
			}
			return new ChipLocation(rootX, rootY);
		}

		/**
		 * Applies a wraparound rule in a particular direction, turning
		 * coordinate space into something of a modular field.
		 *
		 * @param value
		 *            The value to wrap.
		 * @param limit
		 *            The upper limit. (Lower limits are always zero.)
		 * @return The potentially wrapped value.
		 */
		private static int limit(int value, int limit) {
			if (value < 0) {
				return value + limit;
			} else if (value >= limit) {
				return value - limit;
			} else {
				return value;
			}
		}

		TriadCoords move(Direction direction, Machine machine) {
			DirInfo di = DirInfo.get(z, direction);
			return new TriadCoords(limit(x + di.dx, machine.getWidth()),
					limit(y + di.dy, machine.getHeight()), z + di.dz);
		}

		@Override
		public boolean equals(Object obj) {
			if (obj instanceof TriadCoords) {
				TriadCoords other = (TriadCoords) obj;
				return x == other.x && y == other.y && z == other.z;
			}
			return false;
		}

		@Override
		public int hashCode() {
			return (((x << 2 + x) ^ y) << 2 + y) ^ z;
		}

		@Override
		public String toString() {
			return "[x:" + x + ",y:" + y + ",z:" + z + "]";
		}

		@Override
		public int compareTo(TriadCoords other) {
			int cmp = Integer.compare(x, other.x);
			if (cmp != 0) {
				return cmp;
			}
			cmp = Integer.compare(y, other.y);
			if (cmp != 0) {
				return cmp;
			}
			return Integer.compare(z, other.z);
		}
	}

	/**
	 * Frame/BMP coordinates.
	 *
	 * @author Donal Fellows
	 */
	public static final class BMPCoords implements Comparable<BMPCoords> {
		/** Cabinet number. */
		@PositiveOrZero(message = "cabinet number must not be negative")
		public final int c;

		/** Frame number. */
		@PositiveOrZero(message = "frame number must not be negative")
		public final int f;

		public BMPCoords(int c, int f) {
			this.c = c;
			this.f = f;
		}

		private static final Pattern PATTERN;

		static {
			PATTERN = Pattern.compile("^\\[c:(\\d+),f:(\\d+)\\]$");
		}

		public BMPCoords(String serialForm) {
			Matcher m = PATTERN.matcher(serialForm);
			if (!m.matches()) {
				throw new IllegalArgumentException(
						"bad argument: " + serialForm);
			}
			int idx = 0;
			c = Integer.parseInt(m.group(++idx), DECIMAL);
			f = Integer.parseInt(m.group(++idx), DECIMAL);
		}

		@Override
		public boolean equals(Object obj) {
			if (obj instanceof BMPCoords) {
				BMPCoords other = (BMPCoords) obj;
				return c == other.c && f == other.f;
			}
			return false;
		}

		@Override
		public int hashCode() {
			return ((c << 2 + c) ^ f) << 2 + f;
		}

		@Override
		public String toString() {
			return "[c:" + c + ",f:" + f + "]";
		}

		@Override
		public int compareTo(BMPCoords other) {
			int cmp = Integer.compare(c, other.c);
			if (cmp != 0) {
				return cmp;
			}
			return Integer.compare(f, other.f);
		}
	}

	/**
	 * Physical board coordinates.
	 *
	 * @author Donal Fellows
	 */
	public static final class BoardPhysicalCoords
			implements Comparable<BoardPhysicalCoords> {
		/** Cabinet number. */
		@PositiveOrZero(message = "cabinet number must not be negative")
		public final int c;

		/** Frame number. */
		@PositiveOrZero(message = "frame number must not be negative")
		public final int f;

		/** Board number. */
		@PositiveOrZero(message = "board number must not be negative")
		public final int b;

		@JsonCreator
		public BoardPhysicalCoords(@JsonProperty("c") int c,
				@JsonProperty("f") int f, @JsonProperty("b") int b) {
			this.c = c;
			this.f = f;
			this.b = b;
		}

		private static final Pattern PATTERN;

		static {
			PATTERN = Pattern.compile("^\\[c:(\\d+),f:(\\d+),b:(\\d+)\\]$");
		}

		@JsonCreator
		public BoardPhysicalCoords(String serialForm) {
			Matcher m = PATTERN.matcher(serialForm);
			if (!m.matches()) {
				throw new IllegalArgumentException(
						"bad argument: " + serialForm);
			}
			int idx = 0;
			c = Integer.parseInt(m.group(++idx), DECIMAL);
			f = Integer.parseInt(m.group(++idx), DECIMAL);
			b = Integer.parseInt(m.group(++idx), DECIMAL);
		}

		@Override
		public boolean equals(Object obj) {
			if (obj instanceof BoardPhysicalCoords) {
				BoardPhysicalCoords other = (BoardPhysicalCoords) obj;
				return c == other.c && f == other.f && b == other.b;
			}
			return false;
		}

		@Override
		public int hashCode() {
			return (((c << 2 + c) ^ f) << 2 + f) ^ b;
		}

		@Override
		public String toString() {
			return "[c:" + c + ",f:" + f + ",b:" + b + "]";
		}

		BMPCoords bmp() {
			return new BMPCoords(c, f);
		}

		@Override
		public int compareTo(BoardPhysicalCoords other) {
			int cmp = Integer.compare(c, other.c);
			if (cmp != 0) {
				return cmp;
			}
			cmp = Integer.compare(f, other.f);
			if (cmp != 0) {
				return cmp;
			}
			return Integer.compare(b, other.b);
		}
	}

	/**
	 * Enumeration of links from a SpiNNaker chip, as used in the old spalloc.
	 * <p>
	 * Note that the numbers chosen have two useful properties:
	 * <p>
	 * <ul>
	 * <li>The integer values assigned are chosen to match the numbers used to
	 * identify the links in the low-level software API and hardware registers.
	 * <li>The links are ordered consecutively in anticlockwise order meaning
	 * the opposite link is {@code (link+3)%6}.
	 * </ul>
	 * Note that the new Spalloc uses a different notation for link directions!
	 *
	 * @see Direction
	 * @author Donal Fellows
	 */
	public enum Link {
		/** East. */
		east(Direction.SE),
		/** North-East. */
		northEast(Direction.E),
		/** North. */
		north(Direction.N),
		/** West. */
		west(Direction.NW),
		/** South-West. */
		southWest(Direction.W),
		/** South. */
		south(Direction.S);

		private static final Map<Direction, Link> MAP;

		static {
			// This *MUST* be made in the static block
			MAP = new HashMap<>(values().length);
			for (Link l : values()) {
				MAP.put(l.d, l);
			}
		}

		private final Direction d;

		Link(Direction d) {
			this.d = d;
		}

		static Link of(Direction direction) {
			return MAP.get(direction);
		}
	}

	/**
	 * A machine description. JSON-serializable.
	 *
	 * @author Donal Fellows
	 */
	@JsonDeserialize(builder = Machine.Builder.class)
	public static final class Machine {
		private String name;

		private Set<String> tags;

		private int width;

		private int height;

		private Set<TriadCoords> deadBoards;

		private Map<TriadCoords, EnumSet<Link>> deadLinks;

		private Map<TriadCoords,
				BoardPhysicalCoords> boardLocations;

		private Map<BMPCoords, String> bmpIPs;

		private Map<TriadCoords, String> spinnakerIPs;

		/** @return The name of the machine. */
		@NotBlank(message = "machines must have real names")
		public String getName() {
			return name;
		}

		/** @return The tags of the machine. */
		public Set<@NotBlank String> getTags() {
			return unmodifiableSet(tags);
		}

		/** @return The width of the machine, in triads. */
		@Positive(message = "machine width must be greater than zero")
		public int getWidth() {
			return width;
		}

		/** @return The height of the machine, in triads. */
		@Positive(message = "machine height must be greater than zero")
		public int getHeight() {
			return height;
		}

		private static final int FULL_TRIADS = 3;

		/** @return The depth of the machine, the number of boards per triad. */
		public int getDepth() {
			return boardLocations.size() == 1 ? 1 : FULL_TRIADS;
		}

		/** @return The dead boards of the machine. */
		public Set<@Valid TriadCoords> getDeadBoards() {
			return unmodifiableSet(deadBoards);
		}

		/**
		 * @return The extra dead links of the machine. Doesn't include links to
		 *         dead boards.
		 */
		public Map<@Valid TriadCoords, @NotNull EnumSet<Link>> getDeadLinks() {
			return unmodifiableMap(deadLinks);
		}

		/** @return The logical-to-physical board location map. */
		public Map<@Valid TriadCoords, @Valid BoardPhysicalCoords>
				getBoardLocations() {
			return unmodifiableMap(boardLocations);
		}

		/** @return The IP addresses of the BMPs. */
		public Map<@Valid BMPCoords, @IPAddress String> getBmpIPs() {
			return unmodifiableMap(bmpIPs);
		}

		/** @return The IP addresses of the boards. */
		public Map<@Valid TriadCoords, @IPAddress String> getSpinnakerIPs() {
			return unmodifiableMap(spinnakerIPs);
		}

		@Override
		public String toString() {
			return new StringBuilder("Machine(").append("name=").append(name)
					.append(",").append("tags=").append(tags).append(",")
					.append("width=").append(width).append(",")
					.append("height=").append(height).append(",")
					.append("deadBoards=").append(deadBoards).append(",")
					.append("deadLinks=").append(deadLinks).append(",")
					.append("boardLocations=").append(boardLocations)
					.append(",").append("bmpIPs=").append(bmpIPs).append(",")
					.append("spinnakerIPs=").append(spinnakerIPs).append(")")
					.toString();
		}

		@JsonIgnore
		@AssertTrue(message = "all boards must have sane logical coordinates")
		private boolean isCoordinateSane() {
			return boardLocations.keySet().stream().allMatch(loc -> (loc.x >= 0)
					&& (loc.x < width) && (loc.y >= 0) && (loc.y < height));
		}

		@JsonIgnore
		@AssertTrue(message = "all boards must have addresses")
		private boolean isNetworkSane() {
			return spinnakerIPs.size() == boardLocations.size();
		}

		@JsonIgnore
		@AssertTrue(message = "all boards must have BMPs")
		private boolean isBMPSane() {
			return boardLocations.values().stream()
					.allMatch(loc -> bmpIPs.containsKey(loc.bmp()));
		}

		/**
		 * Does a board have a dead link in a given direction?
		 *
		 * @param board
		 *            The location of the board
		 * @param direction
		 *            The direction asking about
		 * @return True iff the board at the given location has a dead link in
		 *         the given direction. Note that if the board doesn't exist at
		 *         all, this returns false.
		 */
		boolean hasDeadLinkAt(TriadCoords board, Direction direction) {
			if (deadLinks.isEmpty()) {
				return false;
			}
			return deadLinks.getOrDefault(board, EnumSet.noneOf(Link.class))
					.contains(Link.of(direction));
		}

		@JsonPOJOBuilder
		static class Builder {
			private String name;

			private Set<String> tags;

			private int width;

			private int height;

			private Set<TriadCoords> deadBoards;

			private Map<TriadCoords, EnumSet<Link>> deadLinks;

			private Map<TriadCoords, BoardPhysicalCoords> boardLocations;

			private Map<BMPCoords, String> bmpIps;

			private Map<TriadCoords, String> spinnakerIps;

			public Builder withName(String name) {
				this.name = name;
				return this;
			}

			public Builder withTags(Set<String> tags) {
				this.tags = tags;
				return this;
			}

			public Builder withWidth(int width) {
				this.width = width;
				return this;
			}

			public Builder withHeight(int height) {
				this.height = height;
				return this;
			}

			public Builder withDeadBoards(Set<TriadCoords> deadBoards) {
				this.deadBoards = deadBoards;
				return this;
			}

			public Builder withDeadLinks(
					Map<TriadCoords, EnumSet<Link>> deadLinks) {
				this.deadLinks = deadLinks;
				return this;
			}

			public Builder withBoardLocations(
					Map<TriadCoords, BoardPhysicalCoords> boardLocations) {
				this.boardLocations = boardLocations;
				return this;
			}

			public Builder withBmpIps(Map<BMPCoords, String> bmpIps) {
				this.bmpIps = bmpIps;
				return this;
			}

			public Builder withSpinnakerIps(
					Map<TriadCoords, String> spinnakerIps) {
				this.spinnakerIps = spinnakerIps;
				return this;
			}

			public Machine build() {
				Machine m = new Machine();
				m.name = name;
				m.tags = tags;
				m.width = width;
				m.height = height;
				m.deadBoards = deadBoards;
				m.deadLinks = deadLinks;
				m.boardLocations = boardLocations;
				m.bmpIPs = bmpIps;
				m.spinnakerIPs = spinnakerIps;
				return m;
			}
		}
	}

	/**
	 * A configuration description. JSON-serializable. Largely ignored as it
	 * represents configuration settings that we handle elsewhere. However, the
	 * {@code machines} property <em>is</em> interesting.
	 *
	 * @author Donal Fellows
	 */
	static final class Configuration {
		private List<Machine> machines;

		private int port;

		private String ip;

		private double timeoutCheckInterval;

		private int maxRetiredJobs;

		private int secondsBeforeFree;

		/** @return The machines to manage. */
		public @NotNull List<@Valid Machine> getMachines() {
			return unmodifiableList(machines);
		}

		public void setMachines(List<Machine> machines) {
			this.machines = machines;
		}

		/** @return The port for the service to listen on. (Ignored) */
		public int getPort() {
			return port;
		}

		public void setPort(int port) {
			this.port = port;
		}

		/**
		 * @return The host address for the service to listen on. Empty = all
		 *         interfaces. (Ignored)
		 */
		public String getIp() {
			return ip;
		}

		public void setIp(String ip) {
			this.ip = ip;
		}

		/** @return How often (in seconds) to check for timeouts. (Ignored) */
		public double getTimeoutCheckInterval() {
			return timeoutCheckInterval;
		}

		public void setTimeoutCheckInterval(double timeoutCheckInterval) {
			this.timeoutCheckInterval = timeoutCheckInterval;
		}

		/** @return How many retired jobs to retain. (Ignored) */
		public int getMaxRetiredJobs() {
			return maxRetiredJobs;
		}

		public void setMaxRetiredJobs(int maxRetiredJobs) {
			this.maxRetiredJobs = maxRetiredJobs;
		}

		/** @return Time to wait before freeing. (Ignored) */
		public int getSecondsBeforeFree() {
			return secondsBeforeFree;
		}

		public void setSecondsBeforeFree(int secondsBeforeFree) {
			this.secondsBeforeFree = secondsBeforeFree;
		}

		@Override
		public String toString() {
			return new StringBuilder("Configuration(").append("machines=")
					.append(machines).append(",").append("port=").append(port)
					.append(",").append("ip=").append(ip).append(",")
					.append("timeoutCheckInterval=")
					.append(timeoutCheckInterval).append(",")
					.append("maxRetiredJobs=").append(maxRetiredJobs)
					.append(",").append("secondsBeforeFree=")
					.append(secondsBeforeFree).append(")").toString();
		}
	}

	@Autowired
	private DatabaseEngine db;

	@Autowired
	private JsonMapper mapper;

	@Autowired
	private ValidatorFactory validatorFactory;

	/**
	 * Read a JSON-converted traditional spalloc configuration and get the
	 * machine definitions from inside.
	 *
	 * @param file
	 *            The file of JSON.
	 * @return The machines from that file.
	 * @throws IOException
	 *             If anything goes wrong with file access.
	 * @throws JsonParseException
	 *             if underlying input contains invalid JSON content
	 * @throws JsonMappingException
	 *             if the input JSON structure does not match the structure of
	 *             JSONified spalloc configuration
	 */
	public List<Machine> readMachineDefinitions(File file)
			throws IOException, JsonParseException, JsonMappingException {
		Configuration cfg =  mapper.readValue(file, Configuration.class);
		for (ConstraintViolation<?> violation : validatorFactory.getValidator()
				.validate(cfg)) {
			// We ought to also say the other problems...
			throw new IOException("failed to validate configuration: "
					+ violation.getMessage());
		}
		return cfg.getMachines();
	}

	/**
	 * The various updates used when inserting a machine. This is
	 * connection-bound.
	 * <p>
	 * Factored out so they can be reused without needing masses of arguments.
	 * <p>
	 * Only non-{@code private} for testing purposes.
	 */
	static class Updates implements AutoCloseable {
		private final Update makeMachine;

		private final Update makeTag;

		private final Update makeBMP;

		private final Update makeBoard;

		private final Update makeLink;

		Updates(Connection conn) throws SQLException {
			this.makeMachine = update(conn, INSERT_MACHINE_SPINN_5);
			this.makeTag = update(conn, INSERT_TAG);
			this.makeBMP = update(conn, INSERT_BMP);
			this.makeBoard = update(conn, INSERT_BOARD);
			this.makeLink = update(conn, INSERT_LINK);
		}

		@Override
		public void close() throws SQLException {
			makeMachine.close();
			makeTag.close();
			makeBMP.close();
			makeBoard.close();
			makeLink.close();
		}
	}

	/**
	 * Add the machine definitions in the given file to the database.
	 *
	 * @param file
	 *            The JSON configuration file.
	 * @throws SQLException
	 *             If database access fails
	 * @throws JsonParseException
	 *             if underlying input contains invalid JSON content
	 * @throws JsonMappingException
	 *             if the input JSON structure does not match the structure of
	 *             JSONified spalloc configuration
	 * @throws IOException
	 *             If the file can't be read
	 */
	public void loadMachineDefinitions(File file) throws SQLException,
			JsonParseException, JsonMappingException, IOException {
		List<Machine> machines = readMachineDefinitions(file);
		try (Connection conn = db.getConnection();
				Updates sql = new Updates(conn)) {
			for (Machine machine : machines) {
				transaction(conn, () -> loadMachineDefinition(sql, machine));
			}
		}
	}

	/**
	 * Add the machine definitions in the given configuration to the database.
	 *
	 * @param configuration
	 *            The configuration.
	 * @throws SQLException
	 *             If database access fails
	 */
	public void loadMachineDefinitions(Configuration configuration)
			throws SQLException {
		try (Connection conn = db.getConnection();
				Updates sql = new Updates(conn)) {
			for (Machine machine : configuration.getMachines()) {
				transaction(conn, () -> loadMachineDefinition(sql, machine));
			}
		}
	}

	/**
	 * Possible exception when an insert fails.
	 *
	 * @author Donal Fellows
	 */
	public static class InsertFailedException extends SQLException {
		private static final long serialVersionUID = -4930512416142843777L;

		InsertFailedException(String table) {
			super("could not insert into " + table);
		}
	}

	/**
	 * Add a machine definition using the SQL update profile.
	 *
	 * @param sql
	 *            The SQL update profile (encapsulates both connection and
	 *            INSERTs).
	 * @param machine
	 *            The description of the machine to add.
	 * @throws SQLException
	 *             If database access fails
	 */
	void loadMachineDefinition(Updates sql, Machine machine)
			throws SQLException {
		int machineId = makeMachine(sql, machine);
		Map<BMPCoords, Integer> bmpIds = makeBMPs(sql, machine, machineId);
		Map<TriadCoords, Integer> boardIds =
				makeBoards(sql, machine, machineId, bmpIds);
		makeLinks(sql, machine, boardIds);
	}

	private int makeMachine(Updates sql, Machine machine)
			throws InsertFailedException, SQLException {
		int machineId = sql.makeMachine.key(machine.getName(),
				machine.getWidth(), machine.getHeight(), machine.getDepth())
				.orElseThrow(() -> new InsertFailedException("machines"));
		// The above will blow up if the machine with that name exists
		for (String tag : machine.getTags()) {
			sql.makeTag.key(machineId, tag);
		}
		return machineId;
	}

	private Map<BMPCoords, Integer> makeBMPs(Updates sql, Machine machine,
			int machineId) throws SQLException {
		Map<BMPCoords, Integer> bmpIds = new HashMap<>();
		for (BMPCoords bmp : machine.bmpIPs.keySet()) {
			sql.makeBMP.key(machineId, machine.bmpIPs.get(bmp), bmp.c, bmp.f)
					.ifPresent(id -> bmpIds.put(bmp, id));
		}
		return bmpIds;
	}

	private Map<TriadCoords, Integer> makeBoards(Updates sql, Machine machine,
			int machineId, Map<BMPCoords, Integer> bmpIds) throws SQLException {
		Map<TriadCoords, Integer> boardIds = new HashMap<>();
		for (TriadCoords triad : machine.boardLocations.keySet()) {
			BoardPhysicalCoords phys = machine.boardLocations.get(triad);
			int bmpID = bmpIds.get(phys.bmp());
			String addr = machine.spinnakerIPs.get(triad);
			ChipLocation root = triad.chipLocation();
			sql.makeBoard
					.key(machineId, addr, bmpID, phys.b, triad.x, triad.y,
							triad.z, root.getX(), root.getY(),
							!machine.deadBoards.contains(triad))
					.ifPresent(id -> boardIds.put(triad, id));
		}
		return boardIds;
	}

	private void makeLinks(Updates sql, Machine machine,
			Map<TriadCoords, Integer> boardIds) throws SQLException {
		for (Entry<TriadCoords, Integer> b : boardIds.entrySet()) {
			TriadCoords here = b.getKey();
			for (Direction d : Direction.values()) {
				TriadCoords there = here.move(d, machine);
				if (!boardIds.containsKey(there)) {
					continue;
				}
				makeLink(sql, machine, boardIds, here, d, there, d.opposite());
				// TODO do we need to keep the link IDs here?
			}
		}
	}

	private Optional<Integer> makeLink(Updates sql, Machine machine,
			Map<TriadCoords, Integer> boardIds, TriadCoords here, Direction d1,
			TriadCoords there, Direction d2) throws SQLException {
		Integer b1 = boardIds.get(here);
		Integer b2 = boardIds.get(there);
		if (b1 == null || b2 == null) {
			// No such board? Oh well
			return Optional.empty();
		}

		// A link is dead if it is dead in either direction
		boolean dead = machine.hasDeadLinkAt(here, d1)
				|| machine.hasDeadLinkAt(there, d2);
		try {
			return sql.makeLink.key(b1, d1, b2, d2, !dead);
		} catch (SQLiteException e) {
			// If the CHECK constraint says no, just ignore; we'll do the link
			// from the other direction. This does mean we're doing too much
			// work, but better to do too much and be reliable
			if (e.getResultCode() == SQLITE_CONSTRAINT_CHECK) {
				return Optional.empty();
			}
			throw e;
		}
	}
}
